{"version":3,"sources":["vector/chunked.ts"],"names":[],"mappings":"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","file":"chunked.js","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from '../data';\nimport { Field } from '../schema';\nimport { clampRange } from '../util/vector';\nimport { DataType, Dictionary } from '../type';\nimport { selectChunkArgs } from '../util/args';\nimport { DictionaryVector } from './dictionary';\nimport { AbstractVector, Vector } from '../vector';\nimport { Clonable, Sliceable, Applicative } from '../vector';\n\n/** @ignore */\ntype ChunkedDict<T extends DataType> = T extends Dictionary ? Vector<T['dictionary']> : null | never;\n/** @ignore */\ntype ChunkedKeys<T extends DataType> = T extends Dictionary ? Vector<T['indices']> | Chunked<T['indices']> : null | never;\n\n/** @ignore */\nexport type SearchContinuation<T extends Chunked> = (column: T, chunkIndex: number, valueIndex: number) => any;\n\n/** @ignore */\nexport class Chunked<T extends DataType = any>\n    extends AbstractVector<T>\n    implements Clonable<Chunked<T>>,\n               Sliceable<Chunked<T>>,\n               Applicative<T, Chunked<T>> {\n\n    /** @nocollapse */\n    public static flatten<T extends DataType>(...vectors: (Vector<T> | Vector<T>[])[]) {\n        return selectChunkArgs<Vector<T>>(Vector, vectors);\n    }\n\n    /** @nocollapse */\n    public static concat<T extends DataType>(...vectors: (Vector<T> | Vector<T>[])[]) {\n        const chunks = Chunked.flatten<T>(...vectors);\n        return new Chunked<T>(chunks[0].type, chunks);\n    }\n\n    protected _type: T;\n    protected _length: number;\n    protected _chunks: Vector<T>[];\n    protected _numChildren: number;\n    protected _children?: Chunked[];\n    protected _nullCount: number = -1;\n    protected _chunkOffsets: Uint32Array;\n\n    constructor(type: T, chunks: Vector<T>[] = [], offsets = calculateOffsets(chunks)) {\n        super();\n        this._type = type;\n        this._chunks = chunks;\n        this._chunkOffsets = offsets;\n        this._length = offsets[offsets.length - 1];\n        this._numChildren = (this._type.children || []).length;\n    }\n\n    public get type() { return this._type; }\n    public get length() { return this._length; }\n    public get chunks() { return this._chunks; }\n    public get typeId(): T['TType'] { return this._type.typeId; }\n    public get VectorName() { return `Chunked<${this._type}>`; }\n    public get data(): Data<T> {\n        return this._chunks[0] ? this._chunks[0].data : <any> null;\n    }\n\n    public get ArrayType() { return this._type.ArrayType; }\n    public get numChildren() { return this._numChildren; }\n    public get stride() { return this._chunks[0] ? this._chunks[0].stride : 1; }\n    public get byteLength(): number {\n        return this._chunks.reduce((byteLength, chunk) => byteLength + chunk.byteLength, 0);\n    }\n    public get nullCount() {\n        let nullCount = this._nullCount;\n        if (nullCount < 0) {\n            this._nullCount = nullCount = this._chunks.reduce((x, { nullCount }) => x + nullCount, 0);\n        }\n        return nullCount;\n    }\n\n    protected _indices?: ChunkedKeys<T>;\n    public get indices(): ChunkedKeys<T> | null {\n        if (DataType.isDictionary(this._type)) {\n            if (!this._indices) {\n                const chunks = (<any> this._chunks) as DictionaryVector<T, any>[];\n                this._indices = (chunks.length === 1\n                    ? chunks[0].indices\n                    : Chunked.concat(...chunks.map((x) => x.indices))) as ChunkedKeys<T>;\n            }\n            return this._indices;\n        }\n        return null;\n    }\n    public get dictionary(): ChunkedDict<T> | null {\n        if (DataType.isDictionary(this._type)) {\n            return this._chunks[this._chunks.length - 1].data.dictionary as ChunkedDict<T>;\n        }\n        return null;\n    }\n\n    public *[Symbol.iterator](): IterableIterator<T['TValue'] | null> {\n        for (const chunk of this._chunks) {\n            yield* chunk;\n        }\n    }\n\n    public clone(chunks = this._chunks): Chunked<T> {\n        return new Chunked(this._type, chunks);\n    }\n\n    public concat(...others: Vector<T>[]): Chunked<T> {\n        return this.clone(Chunked.flatten(this, ...others));\n    }\n\n    public slice(begin?: number, end?: number): Chunked<T> {\n        return clampRange(this, begin, end, this._sliceInternal);\n    }\n\n    public getChildAt<R extends DataType = any>(index: number): Chunked<R> | null {\n\n        if (index < 0 || index >= this._numChildren) { return null; }\n\n        let columns = this._children || (this._children = []);\n        let child: Chunked<R>, field: Field<R>, chunks: Vector<R>[];\n\n        if (child = columns[index]) { return child; }\n        if (field = ((this._type.children || [])[index] as Field<R>)) {\n            chunks = this._chunks\n                .map((vector) => vector.getChildAt<R>(index))\n                .filter((vec): vec is Vector<R> => vec != null);\n            if (chunks.length > 0) {\n                return (columns[index] = new Chunked<R>(field.type, chunks));\n            }\n        }\n\n        return null;\n    }\n\n    public search(index: number): [number, number] | null;\n    public search<N extends SearchContinuation<Chunked<T>>>(index: number, then?: N): ReturnType<N>;\n    public search<N extends SearchContinuation<Chunked<T>>>(index: number, then?: N) {\n        let idx = index;\n        // binary search to find the child vector and value indices\n        let offsets = this._chunkOffsets, rhs = offsets.length - 1;\n        // return early if out of bounds, or if there's just one child\n        if (idx < 0            ) { return null; }\n        if (idx >= offsets[rhs]) { return null; }\n        if (rhs <= 1           ) { return then ? then(this, 0, idx) : [0, idx]; }\n        let lhs = 0, pos = 0, mid = 0;\n        do {\n            if (lhs + 1 === rhs) {\n                return then ? then(this, lhs, idx - pos) : [lhs, idx - pos];\n            }\n            mid = lhs + ((rhs - lhs) / 2) | 0;\n            idx >= offsets[mid] ? (lhs = mid) : (rhs = mid);\n        } while (idx < offsets[rhs] && idx >= (pos = offsets[lhs]));\n        return null;\n    }\n\n    public isValid(index: number): boolean {\n        return !!this.search(index, this.isValidInternal);\n    }\n\n    public get(index: number): T['TValue'] | null {\n        return this.search(index, this.getInternal);\n    }\n\n    public set(index: number, value: T['TValue'] | null): void {\n        this.search(index, ({ chunks }, i, j) => chunks[i].set(j, value));\n    }\n\n    public indexOf(element: T['TValue'], offset?: number): number {\n        if (offset && typeof offset === 'number') {\n            return this.search(offset, (self, i, j) => this.indexOfInternal(self, i, j, element))!;\n        }\n        return this.indexOfInternal(this, 0, Math.max(0, offset || 0), element);\n    }\n\n    public toArray(): T['TArray'] {\n        const { chunks } = this;\n        const n = chunks.length;\n        let ArrayType: any = this._type.ArrayType;\n        if (n <= 0) { return new ArrayType(0); }\n        if (n <= 1) { return chunks[0].toArray(); }\n        let len = 0, src = new Array(n);\n        for (let i = -1; ++i < n;) {\n            len += (src[i] = chunks[i].toArray()).length;\n        }\n        if (ArrayType !== src[0].constructor) {\n            ArrayType = src[0].constructor;\n        }\n        let dst = new ArrayType(len);\n        let set: any = ArrayType === Array ? arraySet : typedSet;\n        for (let i = -1, idx = 0; ++i < n;) {\n            idx = set(src[i], dst, idx);\n        }\n        return dst;\n    }\n\n    protected getInternal({ _chunks }: Chunked<T>, i: number, j: number) { return _chunks[i].get(j); }\n    protected isValidInternal({ _chunks }: Chunked<T>, i: number, j: number) { return _chunks[i].isValid(j); }\n    protected indexOfInternal({ _chunks }: Chunked<T>, chunkIndex: number, fromIndex: number, element: T['TValue']) {\n        let i = chunkIndex - 1, n = _chunks.length;\n        let start = fromIndex, offset = 0, found = -1;\n        while (++i < n) {\n            if (~(found = _chunks[i].indexOf(element, start))) {\n                return offset + found;\n            }\n            start = 0;\n            offset += _chunks[i].length;\n        }\n        return -1;\n    }\n\n    protected _sliceInternal(self: Chunked<T>, begin: number, end: number) {\n        const slices: Vector<T>[] = [];\n        const { chunks, _chunkOffsets: chunkOffsets } = self;\n        for (let i = -1, n = chunks.length; ++i < n;) {\n            const chunk = chunks[i];\n            const chunkLength = chunk.length;\n            const chunkOffset = chunkOffsets[i];\n            // If the child is to the right of the slice boundary, we can stop\n            if (chunkOffset >= end) { break; }\n            // If the child is to the left of of the slice boundary, exclude\n            if (begin >= chunkOffset + chunkLength) { continue; }\n            // If the child is between both left and right boundaries, include w/o slicing\n            if (chunkOffset >= begin && (chunkOffset + chunkLength) <= end) {\n                slices.push(chunk);\n                continue;\n            }\n            // If the child overlaps one of the slice boundaries, include that slice\n            const from = Math.max(0, begin - chunkOffset);\n            const to = Math.min(end - chunkOffset, chunkLength);\n            slices.push(chunk.slice(from, to) as Vector<T>);\n        }\n        return self.clone(slices);\n    }\n}\n\n/** @ignore */\nfunction calculateOffsets<T extends DataType>(vectors: Vector<T>[]) {\n    let offsets = new Uint32Array((vectors || []).length + 1);\n    let offset = offsets[0] = 0, length = offsets.length;\n    for (let index = 0; ++index < length;) {\n        offsets[index] = (offset += vectors[index - 1].length);\n    }\n    return offsets;\n}\n\n/** @ignore */\nconst typedSet = (src: TypedArray, dst: TypedArray, offset: number) => {\n    dst.set(src, offset);\n    return (offset + src.length);\n};\n\n/** @ignore */\nconst arraySet = (src: any[], dst: any[], offset: number) => {\n    let idx = offset;\n    for (let i = -1, n = src.length; ++i < n;) {\n        dst[idx++] = src[i];\n    }\n    return idx;\n};\n\n/** @ignore */\ninterface TypedArray extends ArrayBufferView {\n    readonly length: number;\n    readonly [n: number]: number;\n    set(array: ArrayLike<number>, offset?: number): void;\n}\n"]}