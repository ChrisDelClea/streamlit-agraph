{"version":3,"sources":["recordbatch.ts"],"names":[],"mappings":"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","file":"recordbatch.js","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from './data';\nimport { Table } from './table';\nimport { Vector } from './vector';\nimport { Visitor } from './visitor';\nimport { Schema, Field } from './schema';\nimport { isIterable } from './util/compat';\nimport { Chunked } from './vector/chunked';\nimport { selectFieldArgs } from './util/args';\nimport { DataType, Struct, Dictionary } from './type';\nimport { ensureSameLengthData } from './util/recordbatch';\nimport { Clonable, Sliceable, Applicative } from './vector';\nimport { StructVector, VectorBuilderOptions, VectorBuilderOptionsAsync } from './vector/index';\n\ntype VectorMap = { [key: string]: Vector };\ntype Fields<T extends { [key: string]: DataType }> = (keyof T)[] | Field<T[keyof T]>[];\ntype ChildData<T extends { [key: string]: DataType }> = (Data<T[keyof T]> | Vector<T[keyof T]>)[];\n\nexport interface RecordBatch<T extends { [key: string]: DataType } = any> {\n    concat(...others: Vector<Struct<T>>[]): Table<T>;\n    slice(begin?: number, end?: number): RecordBatch<T>;\n    clone(data: Data<Struct<T>>, children?: Vector[]): RecordBatch<T>;\n}\n\nexport class RecordBatch<T extends { [key: string]: DataType } = any>\n    extends StructVector<T>\n    implements Clonable<RecordBatch<T>>,\n               Sliceable<RecordBatch<T>>,\n               Applicative<Struct<T>, Table<T>> {\n\n    public static from<T extends { [key: string]: DataType } = any, TNull = any>(options: VectorBuilderOptions<Struct<T>, TNull>): Table<T>;\n    public static from<T extends { [key: string]: DataType } = any, TNull = any>(options: VectorBuilderOptionsAsync<Struct<T>, TNull>): Promise<Table<T>>;\n    /** @nocollapse */\n    public static from<T extends { [key: string]: DataType } = any, TNull = any>(options: VectorBuilderOptions<Struct<T>, TNull> | VectorBuilderOptionsAsync<Struct<T>, TNull>) {\n        if (isIterable<(Struct<T>)['TValue'] | TNull>(options['values'])) {\n            return Table.from(options as VectorBuilderOptions<Struct<T>, TNull>);\n        }\n        return Table.from(options as VectorBuilderOptionsAsync<Struct<T>, TNull>);\n    }\n\n    public static new<T extends VectorMap = any>(children: T): RecordBatch<{ [P in keyof T]: T[P]['type'] }>;\n    public static new<T extends { [key: string]: DataType } = any>(children: ChildData<T>, fields?: Fields<T>): RecordBatch<T>;\n    /** @nocollapse */\n    public static new<T extends { [key: string]: DataType } = any>(...args: any[]) {\n        const [fs, xs] = selectFieldArgs<T>(args);\n        const vs = xs.filter((x): x is Vector<T[keyof T]> => x instanceof Vector);\n        return new RecordBatch(...ensureSameLengthData(new Schema<T>(fs), vs.map((x) => x.data)));\n    }\n\n    protected _schema: Schema;\n    protected _dictionaries?: Map<number, Vector>;\n\n    constructor(schema: Schema<T>, length: number, children: (Data | Vector)[]);\n    constructor(schema: Schema<T>, data: Data<Struct<T>>, children?: Vector[]);\n    constructor(...args: any[]) {\n        let data: Data<Struct<T>>;\n        let schema = args[0] as Schema<T>;\n        let children: Vector[] | undefined;\n        if (args[1] instanceof Data) {\n            [, data, children] = (args as [any, Data<Struct<T>>, Vector<T[keyof T]>[]?]);\n        } else {\n            const fields = schema.fields as Field<T[keyof T]>[];\n            const [, length, childData] = args as [any, number, Data<T[keyof T]>[]];\n            data = Data.Struct(new Struct<T>(fields), 0, length, 0, null, childData);\n        }\n        super(data, children);\n        this._schema = schema;\n    }\n\n    public clone(data: Data<Struct<T>>, children = this._children) {\n        return new RecordBatch<T>(this._schema, data, children);\n    }\n\n    public concat(...others: Vector<Struct<T>>[]): Table<T> {\n        const schema = this._schema, chunks = Chunked.flatten(this, ...others);\n        return new Table(schema, chunks.map(({ data }) => new RecordBatch(schema, data)));\n    }\n\n    public get schema() { return this._schema; }\n    public get numCols() { return this._schema.fields.length; }\n    public get dictionaries() {\n        return this._dictionaries || (this._dictionaries = DictionaryCollector.collect(this));\n    }\n\n    public select<K extends keyof T = any>(...columnNames: K[]) {\n        const nameToIndex = this._schema.fields.reduce((m, f, i) => m.set(f.name as K, i), new Map<K, number>());\n        return this.selectAt(...columnNames.map((columnName) => nameToIndex.get(columnName)!).filter((x) => x > -1));\n    }\n    public selectAt<K extends T[keyof T] = any>(...columnIndices: number[]) {\n        const schema = this._schema.selectAt(...columnIndices);\n        const childData = columnIndices.map((i) => this.data.childData[i]).filter(Boolean);\n        return new RecordBatch<{ [key: string]: K }>(schema, this.length, childData);\n    }\n}\n\n/**\n * An internal class used by the `RecordBatchReader` and `RecordBatchWriter`\n * implementations to differentiate between a stream with valid zero-length\n * RecordBatches, and a stream with a Schema message, but no RecordBatches.\n * @see https://github.com/apache/arrow/pull/4373\n * @ignore\n * @private\n */\n/* tslint:disable:class-name */\nexport class _InternalEmptyPlaceholderRecordBatch<T extends { [key: string]: DataType } = any> extends RecordBatch<T> {\n    constructor(schema: Schema<T>) {\n        super(schema, 0, schema.fields.map((f) => Data.new(f.type, 0, 0, 0)));\n    }\n}\n\n/** @ignore */\nclass DictionaryCollector extends Visitor {\n    public dictionaries = new Map<number, Vector>();\n    public static collect<T extends RecordBatch>(batch: T) {\n        return new DictionaryCollector().visit(\n            batch.data, new Struct(batch.schema.fields)\n        ).dictionaries;\n    }\n    public visit(data: Data, type: DataType) {\n        if (DataType.isDictionary(type)) {\n            return this.visitDictionary(data, type);\n        } else {\n            data.childData.forEach((child, i) =>\n                this.visit(child, type.children[i].type));\n        }\n        return this;\n    }\n    public visitDictionary(data: Data, type: Dictionary) {\n        const dictionary = data.dictionary;\n        if (dictionary && dictionary.length > 0) {\n            this.dictionaries.set(type.id, dictionary);\n        }\n        return this;\n    }\n}\n"]}