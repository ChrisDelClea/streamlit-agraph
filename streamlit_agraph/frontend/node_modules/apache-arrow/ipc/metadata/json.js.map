{"version":3,"sources":["ipc/metadata/json.ts"],"names":[],"mappings":"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","file":"json.js","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Schema, Field } from '../../schema';\nimport {\n    DataType, Dictionary, TimeBitWidth,\n    Utf8, Binary, Decimal, FixedSizeBinary,\n    List, FixedSizeList, Map_, Struct, Union,\n    Bool, Null, Int, Float, Date_, Time, Interval, Timestamp, IntBitWidth, Int32, TKeys,\n} from '../../type';\n\nimport { DictionaryBatch, RecordBatch, FieldNode, BufferRegion } from './message';\nimport { TimeUnit, Precision, IntervalUnit, UnionMode, DateUnit } from '../../enum';\n\n/** @ignore */\nexport function schemaFromJSON(_schema: any, dictionaries: Map<number, DataType> = new Map()) {\n    return new Schema(\n        schemaFieldsFromJSON(_schema, dictionaries),\n        customMetadataFromJSON(_schema['customMetadata']),\n        dictionaries\n    );\n}\n\n/** @ignore */\nexport function recordBatchFromJSON(b: any) {\n    return new RecordBatch(\n        b['count'],\n        fieldNodesFromJSON(b['columns']),\n        buffersFromJSON(b['columns'])\n    );\n}\n\n/** @ignore */\nexport function dictionaryBatchFromJSON(b: any) {\n    return new DictionaryBatch(\n        recordBatchFromJSON(b['data']),\n        b['id'], b['isDelta']\n    );\n}\n\n/** @ignore */\nfunction schemaFieldsFromJSON(_schema: any, dictionaries?: Map<number, DataType>) {\n    return (_schema['fields'] || []).filter(Boolean).map((f: any) => Field.fromJSON(f, dictionaries));\n}\n\n/** @ignore */\nfunction fieldChildrenFromJSON(_field: any, dictionaries?: Map<number, DataType>): Field[] {\n    return (_field['children'] || []).filter(Boolean).map((f: any) => Field.fromJSON(f, dictionaries));\n}\n\n/** @ignore */\nfunction fieldNodesFromJSON(xs: any[]): FieldNode[] {\n    return (xs || []).reduce<FieldNode[]>((fieldNodes, column: any) => [\n        ...fieldNodes,\n        new FieldNode(\n            column['count'],\n            nullCountFromJSON(column['VALIDITY'])\n        ),\n        ...fieldNodesFromJSON(column['children'])\n    ], [] as FieldNode[]);\n}\n\n/** @ignore */\nfunction buffersFromJSON(xs: any[], buffers: BufferRegion[] = []): BufferRegion[] {\n    for (let i = -1, n = (xs || []).length; ++i < n;) {\n        const column = xs[i];\n        column['VALIDITY'] && buffers.push(new BufferRegion(buffers.length, column['VALIDITY'].length));\n        column['TYPE'] && buffers.push(new BufferRegion(buffers.length, column['TYPE'].length));\n        column['OFFSET'] && buffers.push(new BufferRegion(buffers.length, column['OFFSET'].length));\n        column['DATA'] && buffers.push(new BufferRegion(buffers.length, column['DATA'].length));\n        buffers = buffersFromJSON(column['children'], buffers);\n    }\n    return buffers;\n}\n\n/** @ignore */\nfunction nullCountFromJSON(validity: number[]) {\n    return (validity || []).reduce((sum, val) => sum + +(val === 0), 0);\n}\n\n/** @ignore */\nexport function fieldFromJSON(_field: any, dictionaries?: Map<number, DataType>) {\n\n    let id: number;\n    let keys: TKeys | null;\n    let field: Field | void;\n    let dictMeta: any;\n    let type: DataType<any>;\n    let dictType: Dictionary;\n\n    // If no dictionary encoding\n    if (!dictionaries || !(dictMeta = _field['dictionary'])) {\n        type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));\n        field = new Field(_field['name'], type, _field['nullable'], customMetadataFromJSON(_field['customMetadata']));\n    }\n    // tslint:disable\n    // If dictionary encoded and the first time we've seen this dictionary id, decode\n    // the data type and child fields, then wrap in a Dictionary type and insert the\n    // data type into the dictionary types map.\n    else if (!dictionaries.has(id = dictMeta['id'])) {\n        // a dictionary index defaults to signed 32 bit int if unspecified\n        keys = (keys = dictMeta['indexType']) ? indexTypeFromJSON(keys) as TKeys : new Int32();\n        dictionaries.set(id, type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));\n        dictType = new Dictionary(type, keys, id, dictMeta['isOrdered']);\n        field = new Field(_field['name'], dictType, _field['nullable'], customMetadataFromJSON(_field['customMetadata']));\n    }\n    // If dictionary encoded, and have already seen this dictionary Id in the schema, then reuse the\n    // data type and wrap in a new Dictionary type and field.\n    else {\n        // a dictionary index defaults to signed 32 bit int if unspecified\n        keys = (keys = dictMeta['indexType']) ? indexTypeFromJSON(keys) as TKeys : new Int32();\n        dictType = new Dictionary(dictionaries.get(id)!, keys, id, dictMeta['isOrdered']);\n        field = new Field(_field['name'], dictType, _field['nullable'], customMetadataFromJSON(_field['customMetadata']));\n    }\n    return field || null;\n}\n\n/** @ignore */\nfunction customMetadataFromJSON(_metadata?: object) {\n    return new Map<string, string>(Object.entries(_metadata || {}));\n}\n\n/** @ignore */\nfunction indexTypeFromJSON(_type: any) {\n    return new Int(_type['isSigned'], _type['bitWidth']);\n}\n\n/** @ignore */\nfunction typeFromJSON(f: any, children?: Field[]): DataType<any> {\n\n    const typeId = f['type']['name'];\n\n    switch (typeId) {\n        case 'NONE':   return new Null();\n        case 'null':   return new Null();\n        case 'binary': return new Binary();\n        case 'utf8':   return new Utf8();\n        case 'bool':   return new Bool();\n        case 'list':   return new List((children || [])[0]);\n        case 'struct': return new Struct(children || []);\n        case 'struct_': return new Struct(children || []);\n    }\n\n    switch (typeId) {\n        case 'int': {\n            const t = f['type'];\n            return new Int(t['isSigned'], t['bitWidth'] as IntBitWidth);\n        }\n        case 'floatingpoint': {\n            const t = f['type'];\n            return new Float(Precision[t['precision']] as any);\n        }\n        case 'decimal': {\n            const t = f['type'];\n            return new Decimal(t['scale'], t['precision']);\n        }\n        case 'date': {\n            const t = f['type'];\n            return new Date_(DateUnit[t['unit']] as any);\n        }\n        case 'time': {\n            const t = f['type'];\n            return new Time(TimeUnit[t['unit']] as any, t['bitWidth'] as TimeBitWidth);\n        }\n        case 'timestamp': {\n            const t = f['type'];\n            return new Timestamp(TimeUnit[t['unit']] as any, t['timezone']);\n        }\n        case 'interval': {\n            const t = f['type'];\n            return new Interval(IntervalUnit[t['unit']] as any);\n        }\n        case 'union': {\n            const t = f['type'];\n            return new Union(UnionMode[t['mode']] as any, (t['typeIds'] || []), children || []);\n        }\n        case 'fixedsizebinary': {\n            const t = f['type'];\n            return new FixedSizeBinary(t['byteWidth']);\n        }\n        case 'fixedsizelist': {\n            const t = f['type'];\n            return new FixedSizeList(t['listSize'], (children || [])[0]);\n        }\n        case 'map': {\n            const t = f['type'];\n            return new Map_((children || [])[0], t['keysSorted']);\n        }\n    }\n    throw new Error(`Unrecognized type: \"${typeId}\"`);\n}\n"]}