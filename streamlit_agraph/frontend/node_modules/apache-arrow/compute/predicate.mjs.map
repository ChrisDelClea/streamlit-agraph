{"version":3,"sources":["compute/predicate.ts"],"names":[],"mappings":"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","file":"predicate.js","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Vector } from '../vector';\nimport { RecordBatch } from '../recordbatch';\nimport { DictionaryVector } from '../vector/dictionary';\n\n/** @ignore */\nexport type ValueFunc<T> = (idx: number, cols: RecordBatch) => T | null;\n/** @ignore */\nexport type PredicateFunc = (idx: number, cols: RecordBatch) => boolean;\n\n/** @ignore */\nexport abstract class Value<T> {\n    eq(other: Value<T> | T): Predicate {\n        if (!(other instanceof Value)) { other = new Literal(other); }\n        return new Equals(this, other);\n    }\n    le(other: Value<T> | T): Predicate {\n        if (!(other instanceof Value)) { other = new Literal(other); }\n        return new LTeq(this, other);\n    }\n    ge(other: Value<T> | T): Predicate {\n        if (!(other instanceof Value)) { other = new Literal(other); }\n        return new GTeq(this, other);\n    }\n    lt(other: Value<T> | T): Predicate {\n        return new Not(this.ge(other));\n    }\n    gt(other: Value<T> | T): Predicate {\n        return new Not(this.le(other));\n    }\n    ne(other: Value<T> | T): Predicate {\n        return new Not(this.eq(other));\n    }\n}\n\n/** @ignore */\nexport class Literal<T= any> extends Value<T> {\n    constructor(public v: T) { super(); }\n}\n\n/** @ignore */\nexport class Col<T= any> extends Value<T> {\n    // @ts-ignore\n    public vector: Vector;\n    // @ts-ignore\n    public colidx: number;\n\n    constructor(public name: string) { super(); }\n    bind(batch: RecordBatch): (idx: number, batch?: RecordBatch) => any {\n        if (!this.colidx) {\n            // Assume column index doesn't change between calls to bind\n            //this.colidx = cols.findIndex(v => v.name.indexOf(this.name) != -1);\n            this.colidx = -1;\n            const fields = batch.schema.fields;\n            for (let idx = -1; ++idx < fields.length;) {\n                if (fields[idx].name === this.name) {\n                    this.colidx = idx;\n                    break;\n                }\n            }\n            if (this.colidx < 0) { throw new Error(`Failed to bind Col \"${this.name}\"`); }\n        }\n\n        const vec = this.vector = batch.getChildAt(this.colidx)!;\n        return (idx: number) => vec.get(idx);\n    }\n}\n\n/** @ignore */\nexport abstract class Predicate {\n    abstract bind(batch: RecordBatch): PredicateFunc;\n    and(...expr: Predicate[]): And { return new And(this, ...expr); }\n    or(...expr: Predicate[]): Or { return new Or(this, ...expr); }\n    not(): Predicate { return new Not(this); }\n}\n\n/** @ignore */\nexport abstract class ComparisonPredicate<T= any> extends Predicate {\n    constructor(public readonly left: Value<T>, public readonly right: Value<T>) {\n        super();\n    }\n\n    bind(batch: RecordBatch) {\n        if (this.left instanceof Literal) {\n            if (this.right instanceof Literal) {\n                return this._bindLitLit(batch, this.left, this.right);\n            } else { // right is a Col\n\n                return this._bindLitCol(batch, this.left, this.right as Col);\n            }\n        } else { // left is a Col\n            if (this.right instanceof Literal) {\n                return this._bindColLit(batch, this.left as Col, this.right);\n            } else { // right is a Col\n                return this._bindColCol(batch, this.left as Col, this.right as Col);\n            }\n        }\n    }\n\n    protected abstract _bindLitLit(batch: RecordBatch, left: Literal, right: Literal): PredicateFunc;\n    protected abstract _bindColCol(batch: RecordBatch, left: Col, right: Col): PredicateFunc;\n    protected abstract _bindColLit(batch: RecordBatch, col: Col, lit: Literal): PredicateFunc;\n    protected abstract _bindLitCol(batch: RecordBatch, lit: Literal, col: Col): PredicateFunc;\n}\n\n/** @ignore */\nexport abstract class CombinationPredicate extends Predicate {\n    readonly children: Predicate[];\n    constructor(...children: Predicate[]) {\n        super();\n        this.children = children;\n    }\n}\n// add children to prototype so it doesn't get mangled in es2015/umd\n(<any> CombinationPredicate.prototype).children = Object.freeze([]); // freeze for safety\n\n/** @ignore */\nexport class And extends CombinationPredicate {\n    constructor(...children: Predicate[]) {\n        // Flatten any Ands\n        children = children.reduce((accum: Predicate[], p: Predicate): Predicate[] => {\n            return accum.concat(p instanceof And ? p.children : p);\n        }, []);\n        super(...children);\n    }\n    bind(batch: RecordBatch) {\n        const bound = this.children.map((p) => p.bind(batch));\n        return (idx: number, batch: RecordBatch) => bound.every((p) => p(idx, batch));\n    }\n}\n\n/** @ignore */\nexport class Or extends CombinationPredicate {\n    constructor(...children: Predicate[]) {\n        // Flatten any Ors\n        children = children.reduce((accum: Predicate[], p: Predicate): Predicate[] => {\n            return accum.concat(p instanceof Or ? p.children : p);\n        }, []);\n        super(...children);\n    }\n    bind(batch: RecordBatch) {\n        const bound = this.children.map((p) => p.bind(batch));\n        return (idx: number, batch: RecordBatch) => bound.some((p) => p(idx, batch));\n    }\n}\n\n/** @ignore */\nexport class Equals extends ComparisonPredicate {\n    // Helpers used to cache dictionary reverse lookups between calls to bind\n    private lastDictionary: Vector|undefined;\n    private lastKey: number|undefined;\n\n    protected _bindLitLit(_batch: RecordBatch, left: Literal, right: Literal): PredicateFunc {\n        const rtrn: boolean = left.v == right.v;\n        return () => rtrn;\n    }\n\n    protected _bindColCol(batch: RecordBatch, left: Col, right: Col): PredicateFunc {\n        const left_func = left.bind(batch);\n        const right_func = right.bind(batch);\n        return (idx: number, batch: RecordBatch) => left_func(idx, batch) == right_func(idx, batch);\n    }\n\n    protected _bindColLit(batch: RecordBatch, col: Col, lit: Literal): PredicateFunc {\n        const col_func = col.bind(batch);\n        if (col.vector instanceof DictionaryVector) {\n            let key: any;\n            const vector = col.vector as DictionaryVector;\n            if (vector.dictionary !== this.lastDictionary) {\n                key = vector.reverseLookup(lit.v);\n                this.lastDictionary = vector.dictionary;\n                this.lastKey = key;\n            } else {\n                key = this.lastKey;\n            }\n\n            if (key === -1) {\n                // the value doesn't exist in the dictionary - always return\n                // false\n                // TODO: special-case of PredicateFunc that encapsulates this\n                // \"always false\" behavior. That way filtering operations don't\n                // have to bother checking\n                return () => false;\n            } else {\n                return (idx: number) => {\n                    return vector.getKey(idx) === key;\n                };\n            }\n        } else {\n            return (idx: number, cols: RecordBatch) => col_func(idx, cols) == lit.v;\n        }\n    }\n\n    protected _bindLitCol(batch: RecordBatch, lit: Literal, col: Col) {\n        // Equals is commutative\n        return this._bindColLit(batch, col, lit);\n    }\n}\n\n/** @ignore */\nexport class LTeq extends ComparisonPredicate {\n    protected _bindLitLit(_batch: RecordBatch, left: Literal, right: Literal): PredicateFunc {\n        const rtrn: boolean = left.v <= right.v;\n        return () => rtrn;\n    }\n\n    protected _bindColCol(batch: RecordBatch, left: Col, right: Col): PredicateFunc {\n        const left_func = left.bind(batch);\n        const right_func = right.bind(batch);\n        return (idx: number, cols: RecordBatch) => left_func(idx, cols) <= right_func(idx, cols);\n    }\n\n    protected _bindColLit(batch: RecordBatch, col: Col, lit: Literal): PredicateFunc {\n        const col_func = col.bind(batch);\n        return (idx: number, cols: RecordBatch) => col_func(idx, cols) <= lit.v;\n    }\n\n    protected _bindLitCol(batch: RecordBatch, lit: Literal, col: Col) {\n        const col_func = col.bind(batch);\n        return (idx: number, cols: RecordBatch) => lit.v <= col_func(idx, cols);\n    }\n}\n\n/** @ignore */\nexport class GTeq extends ComparisonPredicate {\n    protected _bindLitLit(_batch: RecordBatch, left: Literal, right: Literal): PredicateFunc {\n        const rtrn: boolean = left.v >= right.v;\n        return () => rtrn;\n    }\n\n    protected _bindColCol(batch: RecordBatch, left: Col, right: Col): PredicateFunc {\n        const left_func = left.bind(batch);\n        const right_func = right.bind(batch);\n        return (idx: number, cols: RecordBatch) => left_func(idx, cols) >= right_func(idx, cols);\n    }\n\n    protected _bindColLit(batch: RecordBatch, col: Col, lit: Literal): PredicateFunc {\n        const col_func = col.bind(batch);\n        return (idx: number, cols: RecordBatch) => col_func(idx, cols) >= lit.v;\n    }\n\n    protected _bindLitCol(batch: RecordBatch, lit: Literal, col: Col) {\n        const col_func = col.bind(batch);\n        return (idx: number, cols: RecordBatch) => lit.v >= col_func(idx, cols);\n    }\n}\n\n/** @ignore */\nexport class Not extends Predicate {\n    constructor(public readonly child: Predicate) {\n        super();\n    }\n\n    bind(batch: RecordBatch) {\n        const func = this.child.bind(batch);\n        return (idx: number, batch: RecordBatch) => !func(idx, batch);\n    }\n}\n\n/** @ignore */\nexport class CustomPredicate extends Predicate {\n    constructor(private next: PredicateFunc, private bind_: (batch: RecordBatch) => void) {\n        super();\n    }\n\n    bind(batch: RecordBatch) {\n        this.bind_(batch);\n        return this.next;\n    }\n}\n\nexport function lit(v: any): Value<any> { return new Literal(v); }\nexport function col(n: string): Col<any> { return new Col(n); }\nexport function and(...p: Predicate[]): And { return new And(...p); }\nexport function or(...p: Predicate[]): Or { return new Or(...p); }\nexport function custom(next: PredicateFunc, bind: (batch: RecordBatch) => void) {\n    return new CustomPredicate(next, bind);\n}\n"]}